######
coding
######

0: about this project
=====================

me solving coderun, codeforces, codewars and leetcode problems to 'git gud'.

1.1: project layout
===================

- :code:`root`: The :code:`CMakeLists.txt` and :code:`.command` files are located directly in the root folder.

  - :code:`/bin`: contains the :code:`solution` executable file.

  - :code:`/build`: contains the :code:`cmake` generated build files.

  - :code:`/source`: contains the :code:`solution.cpp` source file.

2: cmake
========

.. code-block::

	cmake_minimum_required(VERSION 3.28)
	project("coding")

	set (CMAKE_CXX_STANDARD 11)

	add_executable(solution 
	  "source/solution.cpp"
	)

	install(TARGETS solution DESTINATION "${PROJECT_SOURCE_DIR}/bin/")

3: build
========

- :code:`solution.command` contains the following:

  - :code:`~/projectRoot rm -rf build/` and :code:`~/projectRoot mkdir build` basically clears the build directory.

  - :code:`cd build`: enters the directory.

  - :code:`cmake ..`: builds the :code:`CMakeLists.txt` located in the parent directory.

  - :code:`make install`: creates the :code:`solution` executable and puts it in the :code:`~/projectRoot/bin` directory.

  - :code:`cd ../bin`: enters the /bin directory.

  - :code:`./solution`: launches the executable.

4: problems
===========

coderun: intro.
---------------

юля, никита и задачи.
~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_001.cpp` :: :code:`coderun` : :code:`easy` :

  - Подготовка задач к сезону это долгий и кропотливый процесс. Юля знает, что уже готово A задач. Никита выяснил, что ещё B задач почти готовы и в ближайшее время будут добавлены в сезон. Помогите Юле и Никите узнать, сколько всего задач планируется в сезоне.

  - :code:`формат ввода`	: Первая строка содержит два числа *A* и *B* (0 <= *A, B* <= 2 * 10\ :sup:`18`), разделённые пробелом.

  - :code:`формат вывода`	: Выведите одно число - *A* + *B* - суммарное количество задач в сезоне.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 1 1 -> 2.

  - :code:`пример 2`		: 4 1 -> 5.

  - :code:`пример 3`		: 1 3 -> 4.

треугольник.
~~~~~~~~~~~~

- :code:`coderun_002.cpp` :: :code:`coderun` : :code:`easy` : :code:`geometry` :

  - Даны три натуральных числа. Возможно ли построить треугольник с такими сторонами? Если это возможно, выведите строку YES, иначе выведите строку NO. Треугольник — это три точки, не лежащие на одной прямой.

  - :code:`формат ввода`	: Вводятся три натуральных числа.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 3 4 5 -> YES.

  - :code:`пример 2`		: 3 5 4 -> YES.

  - :code:`пример 3`		: 4 5 3 -> YES.

больше чем соседи.
~~~~~~~~~~~~~~~~~~

- :code:`coderun_003.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search` :

  - Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей. Выведите количество таких элементов.

  - :code:`формат ввода`	: Вводится список чисел. Все числа списка находятся на одной строке.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 1 2 3 4 5 -> 0.

  - :code:`пример 2`		: 5 4 3 2 1 -> 0.

  - :code:`пример 3`		: 1 5 1 5 1 -> 0.

выставление тегов
~~~~~~~~~~~~~~~~~

- :code:`coderun_004.cpp` :: :code:`coderun` : :code:`easy` :

  - Большинство задач сезона CodeRun имеют теги, помогающие пользователям выбрать подходящий алгоритм для решения. Известно, что для первой и второй задач каждого трека количество тегов равно 1 (*t* [1]= *t* [2]=1), а для всех следующих количество тегов вычисляется по следующему правилу: *t* [*i*]= *t* [*i* − 1]+ *t* [*i* −2], где *t* [*i*] - количество тегов задачи с номером *i*. Было установлено, что на выставление одного тега требуется одна секунда. Посчитайте, сколько всего времени потребуется для выставления всех тегов.

  - :code:`формат ввода`	: На вход подаётся одно целое число *n* (1 <= *n* <= 35) - количество задач в треке.

  - :code:`формат вывода`	: Выведите одно целое число - сумму *t* [*i*] - время, необходимое для расстановки тегов всех задач.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 32 -> 5702866.

  - :code:`пример 2`		: 21 -> 28656.

  - :code:`пример 3`		: 33 -> 9227464.

29 задача аналитики
~~~~~~~~~~~~~~~~~~~

- :code:`coderun_005.cpp` :: :code:`coderun` : :code:`easy` :

  - В трек аналитики второго сезона вошло 28 задач, однако кроме них была подготовлена ещё одна задача. Так как в сезон она не вошла, то предлагаем решить вам её сейчас. Вам дано квадратное уравнение вида: *ax*\ :sup:`2` + *bx* + *c* = 0, где *a*, *b* и *c* - целые числа, такие, что *a* != 0. Напишите программу, которая решает это уравнение.

  - :code:`формат ввода`	: Единственная строка входных данных содержит три целых числа *a*, *b*, *c* (-10\ :sup:`3` <= *a*, *b*, *c* <= 10\ :sup:`3`, a != 0).

  - :code:`формат вывода`	: В первой строке выведите количество корней уравнения. Во второй строке выведите сами корни. Если уравнение имеет два корня, то выведите их через пробел в порядке **возрастания**. Если корень один, то выведите его. Если корней нет, то ничего выводить не нужно. Ваш ответ будет принят, если выведенные числа отличаются от правильных ответов на величину не более 10\ :sup:`-6`.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 -2  1 -> 1/n1.000000.

  - :code:`пример 2`		:  5  0  3 -> 0.

  - :code:`пример 3`		:  6 -5 -8 -> 2/n-0.810910 1.644243

OpenCalculator
~~~~~~~~~~~~~~

- :code:`coderun_006.cpp` :: :code:`coderun` : :code:`easy` : :code:`set` : :code:`standard library` :

  - В новой программе OpenCalculator появилась новая возможность – можно настроить, какие кнопки отображаются, а какие – нет. Если кнопка не отображается на экране, то ввести соответствующую цифру с клавиатуры или копированием из другой программы нельзя. Петя настроил калькулятор так, что он отображает только кнопки с цифрами x, y, z. Напишите программу, определяющую, сможет ли Петя ввести число N, а если нет, то какое минимальное количество кнопок надо дополнительно отобразить на экране для его ввода.

  - :code:`формат ввода`	: Сначала вводятся три различных числа из диапазона от 0 до 9: x, y и z (числа разделяются пробелами). Далее вводится целое неотрицательное число N, которое Петя хочет ввести в калькулятор. Число N не превышает 10000.

  - :code:`формат вывода`	: Выведите, какое минимальное количество кнопок должно быть добавлено для того, чтобы можно было ввести число N (если число может быть введено с помощью уже имеющихся кнопок, выведите 0).

  - :code:`примечание`	: Комментарии к примерам тестов.

    - Число может быть введено имеющимися кнопками.

    - Нужно добавить кнопку 0.

    - Нужно добавить кнопки 1 и 2.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 2 3/n1123 -> 0.

  - :code:`пример 2`		:  1 2 3/n1001 -> 1.

  - :code:`пример 3`		:  5 7 3/n123  -> 2.

количество слов в тексте
~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_007.cpp` :: :code:`coderun` : :code:`easy` : :code:`line handling` : :code:`set` : :code:`standard library` :

  - Во входном файле записан текст (вы можете читать данные из sys.stdin, подключив библиотеку sys). Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Определите, сколько **различных** слов содержится в этом тексте.

  - :code:`формат ввода`	: Вводится текст.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

возрастает ли список?
~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_008.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search` :

  - Дан список. Определите, является ли он монотонно возрастающим (то есть верно ли, что каждый элемент этого списка строго больше предыдущего). Выведите YES, если массив монотонно возрастает и NO в противном случае.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 7 9 -> YES.

  - :code:`пример 2`		:  1 9 7 -> NO.

  - :code:`пример 3`		:  2 2 2 -> NO.

умножай и транспонируй
~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_009.cpp` :: :code:`coderun` : :code:`easy` :

  - Школьники из объединения КРОШ (Клуб Решателей Олимпиад Школьников) готовятся к участию в треке ML. Начать подготовку они решили с изучения линейной алгебры. Выяснилось, что существует две интересные операции над матрицами - умножение и траспонирование. Они составили много примеров и решают их на листике, однако им нужна помощь в проверке результатов. Напишите программу, которая по заданным матрицам *A* и *B* вычисляет: ( *A* × *B* )\ :sup:`T`, где *A* - матрица размером *n* × *m*, а *B* - матрица размером *m* × *k*.

  - :code:`формат ввода`	: В первой стоке вводятся 3 числа *n*, *m*, *k* (1 <= *n*, *m*, *k* <= 100). Далее следуют *n* строк по *m* чисел в каждой - элементы матрицы *A* (0 <= *A*\ :sub:`i,j`\  <= 10). Затем вводятся *m* строк по *k* чисел в каждой - элементы матрицы *B* (0 <= *B*\ :sub:`i,j`\   <= 10).

  - :code:`формат вывода`	: Выведите матрицу результата операции ( *A* × *B* )\ :sup:`T`.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 2 1/n3 4/n9/n8 -> 59.

  - :code:`пример 2`		:  2 1 3/n0/n2/n1 2 8 -> 0 2/n0 4/n0 16.

  - :code:`пример 3`		:  6 1 4/n6/n1/n3/n3/n1/n9/n10 2 0 3 -> 60 10 30 30 10 90/n12 2 6 6 2 18/n0 0 0 0 0 0/n18 3 9 9 3 27.

ещё одна задача на теорию чисел
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_010.cpp` :: :code:`coderun` : :code:`easy` :

  - Лене очень нравится теория чисел. В прошлый раз она просила участников сезона угадать функцию Эйлера. К сожалению, для некоторых пользователей эта задача оказалась слишком сложной, поэтому Лена придумала задачку попроще. Вам даны 2 натуральных числа *a* и *b*. Необходимо посчитать НОД(a, b) и НОК(a, b). Напомним, что: НОД(a, b) - наибольшее натуральное число, на которое числа *a* и *b* делятся без остатка. НОК(a, b) - ннаименьшее натуральное число, которое делится на числа *a* и *b* без остатка.

  - :code:`формат ввода`	: Единственная входная строка содержит два числа - *a*, *b* (1 <= *a*, *b* <= 10\ :sup:`9`).

  - :code:`формат вывода`	: Выведите 2 целых числа - НОД(a, b) и НОД(a, b).

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  20 8 -> 4 40.

  - :code:`пример 2`		:  2 3 -> 1 6.

  - :code:`пример 3`		:  5 15 -> 5 15.

словарь синонимов
~~~~~~~~~~~~~~~~~

- :code:`coderun_011.cpp` :: :code:`coderun` : :code:`easy` : :code:`standard library` : :code:`dict`

  - Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.

  - :code:`формат ввода`	: Программа получает на вход количество пар синонимов *N*. Далее следует *N* строк, каждая строка содержит ровно два слова-синонима. После этого следует одно слово.

  - :code:`формат вывода`	: Программа должна вывести синоним к данному слову.

  - :code:`примечание`		: Эту задачу можно решить и без словарей (сохранив все входные данные в списке), но решение со словарем будет более простым.

  - :code:`ограничения`		: 1 с, 256 мб.

  - :code:`пример 1`		:  3/nHello Hi/nBye Goodbye/nList Array/nGoodbye -> Bye.

  - :code:`пример 2`		:  1/nbeep Car/nCar -> beep.

  - :code:`пример 3`		:  2/nOlolo Ololo/nNumbers 1234567890/nNumbers -> 1234567890.

ближайшее число
~~~~~~~~~~~~~~~

- :code:`coderun_012.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search`

  - Напишите программу, которая находит в массиве элемент, самый близкий по величине к данному числу.

  - :code:`формат ввода`	: В первой строке задается одно натуральное число *N*, не превосходящее 1000 — размер массива. Во второй строке содержатся *N* чисел — элементы массива, целые числа, не превосходящие по модулю 1000. В третьей строке вводится одно целое число *x*, не превосходящее по модулю 1000.

  - :code:`формат вывода`	: Вывести значение элемента массива, ближайшее к *x*. Если таких чисел несколько, выведите любое из них.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  5/n1 2 3 4 5/n6 -> 5.

  - :code:`пример 2`		:  5/n5 4 3 2 1/n3 -> 3.

симметричная последовательность
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_013.cpp` :: :code:`coderun` : :code:`easy` : :code:`implementation`

  - Последовательность чисел назовём симметричной, если она одинаково читается как слева направо, так и справа налево. Например, следующие последовательности являются симметричными: 1 2 3 4 5 4 3 2 1 и 1 2 1 2 2 1 2 1. Вашей программе будет дана последовательность чисел. Требуется определить, какое минимальное количество и каких чисел надо приписать в конец этой последовательности, чтобы она стала симметричной.

  - :code:`формат ввода`	: Сначала вводится число *N* — количество элементов исходной последовательности (1 <= *N* <= 100). Далее идут *N* чисел — элементы этой последовательности, натуральные числа от 1 до 9.

  - :code:`формат вывода`	: Выведите сначала число *M* — минимальное количество элементов, которое надо дописать к последовательности, а потом *M* чисел (каждое — от 1 до 9) — числа, которые надо дописать к последовательности.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  9/n1 2 3 4 5 4 3 2 1 -> 0.

  - :code:`пример 2`		:  5/n1 2 1 2 2 -> 3/n1 2 1.

  - :code:`пример 3`		:  5/n1 2 3 4 5 -> 4/n4 3 2 1.

наибольшее произведение трёх чисел
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_014.cpp` :: :code:`coderun` : :code:`easy` : :code:`sort`

  - В данном массиве из *n* целых чисел найдите три числа, произведение которых максимально.

  - :code:`формат ввода`	: В единственной строке расположено *n* *A* (3 <= *n* <= 10\ :sup:`5`) чисел *a*\ :sub:`i` (-10\ :sup:`6` <=  *a*\ :sub:`i` <= 10\ :sup:`6`) - элементы массива.

  - :code:`формат вывода`	: Выведите три элемента массива, дающих наибольшее произведение, в любом порядке.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  3 5 1 7 9 0 9 -3 10 -> 10 9 9.

  - :code:`пример 2`		:  -5 -30000 -12 -> -5 -12 -30000.

  - :code:`пример 3`		:  1 2 3 -> 3 2 1.

определить вид последовательности
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_015.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search`

  - По последовательности чисел во входных данных определите ее вид:

    - *CONSTANT* — последовательность состоит из одинаковых значений

    - *ASCENDING* — последовательность является строго возрастающей

    - *WEAKLY ASCENDING* — последовательность является нестрого возрастающей

    - *DESCENDING* — последовательность является строго убывающей

    - *WEAKLY DESCENDING* — последовательность является нестрого убывающей

    - *RANDOM* — последовательность не принадлежит ни к одному из вышеупомянутых типов

  - :code:`формат ввода`	: По одному на строке поступают числа последовательности *a*\ :sub:`i`, | *a*\ :sub:`i`| <= 10\ :sup:`9`. Признаком окончания последовательности является число -2 * 10\ :sup:`9`. *Оно в последовательность не входит*.

  - :code:`формат вывода`	: В единственной строке выведите тип последовательности.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  -530/n-530/n ... /n-530/n-2000000000 -> CONSTANT.

улучшение успеваемости
~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_016.cpp` :: :code:`coderun` : :code:`easy` : :code:`binary search`

  - В лицее на уроках информатики ответы учеников оцениваются целым числом баллов от 2 до 5 . Итоговая оценка по информатике выставляется как среднее арифметическое оценок на всех уроках, округленное до ближайшего целого числа. Если среднее значение находится ровно посередине между двумя целыми числами, то оценка округляется вверх. Все ученики лицея стремятся получить итоговую оценку по информатике не ниже 4 баллов. К сожалению, один из учеников получил на уроках a двоек, b троек и c четвёрок. Теперь он планирует получить несколько пятёрок, причем хочет, чтобы итоговая оценка была не меньше 4 баллов. Ему надо понять, какое минимальное количество пятёрок ему необходимо получить, чтобы добиться своей цели. Требуется написать программу, которая по заданным целым неотрицательным числам a, b и c определяет минимальное количество пятёрок, которое необходимо получить ученику, чтобы его итоговая оценка по информатике была не меньше 4 баллов.

  - :code:`формат ввода`	: Входные данные содержат три строки. Первая строка содержит целое неотрицательное число a , вторая строка содержит целое неотрицательное число b , третья строка содержит целое неотрицательное число c (0 <= a, b, c <= 10\ :sup:`15`, a + b + c >= 1).

  - :code:`формат вывода`	: Выходные данные должны содержать одно число: минимальное число пятерок, которое необходимо получить ученику, чтобы итоговая оценка была не меньше 4 баллов.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  2/n0/n0 -> 2.

сапёр
~~~~~

- :code:`coderun_017.cpp` :: :code:`coderun` : :code:`easy` : :code:`implementation`

  - Вам необходимо построить поле для игры «Сапер» по его конфигурации — размерам и координатам расставленных на нём мин. Вкратце напомним правила построения поля для игры «Сапер»:

    - Поле состоит из клеток с минами и пустых клеток

    - Клетки с миной обозначаются символом *

    - Пустые клетки содержат число *k*\ :sup:`*i, j*`, 0 <= *k*\ :sup:`*i, j*` <= 8 — количество мин на соседних клетках. Соседними клетками являются восемь клеток, имеющих смежный угол или сторону.

  - :code:`формат ввода`	: В первой строке содержатся три числа: *N*, 1 <= *N* <= 100 - количество строк на поле, *M*, 1 <= *M* <= 100 - количество столбцов на поле, *K*, 0 <= *K* <= *N* × *M* - количество мин на поле. В следующих *K* строках содержатся по два числа с координатами мин: *p*, 1 <= *p* <= *N* - номер строки мины, *q*, 1 <= *q* <= *M* - номер столбца мины.

  - :code:`формат вывода`	: Выведите построенное поле, разделяя строки поля переводом строки, а столбцы - пробелом.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  3 2 2/n1 1/n2 2 -> * 2/n2 */n1 1.

  - :code:`пример 2`		:  2 2 0 -> * 0 0/n0 0.

  - :code:`пример 3`		:  4 4 4/n1 3/n2 1/n4 2/n 4 4 -> * 1 2 * 1/n* 2 1 1/n2 2 2 1/n1 * 2 *.

поиск в глубину
~~~~~~~~~~~~~~~

- :code:`coderun_018.cpp` :: :code:`coderun` : :code:`easy` : :code:`dfs'

  - Дан неориентированный граф, возможно с петлями и кратными ребрами. Необходимо найти компоненту связности, содержащую вершину с номером 1.

  - :code:`формат ввода`	: В первой строке записаны два целых числа *N* (1 <= *N* <= 10\ :sup:`3`) и *M* (0 <= *M* <= 5 * 10\ :sup:`5`)— количество вершин и ребер в графе. В последующих *M* строках перечислены ребра — пары чисел, определяющие номера вершин, которые соединяют ребра. Вершины нумеруются с единицы.

  - :code:`формат вывода`	: - :code:`формат вывода`	: В первой строке выведите число *K* — количество вершин в компоненте связности. Во второй строке выведите *K* целых чисел — вершины компоненты связности, перечисленные в порядке *возрастания номеров*.

  - :code:`примечание`		:

    - *Петля в графе* — это ребро, которое соединяет вершину с самой собой.

    - *Кратные рёбра в графе* — это рёбра, которые соединяют одну и ту же пару вершин.

    - *Компонента связности в неориентированном графе* — это подмножество вершин таких, что все вершины достижимы друг из друга.

  - :code:`ограничения`		: 1 с, 256 мб.

  - :code:`пример 1`		:  4 5/n2 2/n3 4/n2 3/n1 3/n2 4 -> 4/n1 2 3 4.

узник замка иф
~~~~~~~~~~~~~~

- :code:`coderun_019.cpp` :: :code:`coderun` : :code:`easy` : :code:`implementation`

  - За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером *D* × *E*. Замок Иф сложен из кирпичей, размером *A* × *B* × *C*. Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие, если стороны кирпича должны быть параллельны сторонам отверстия.

  - :code:`формат ввода`	: Программа получает на вход числа *A*, *B*, *C*, *D*, *E*(1 <= *A*, *B*, *C*, *D*, *E* <= 10\ :sup:`4`);

  - :code:`формат вывода`	: Программа должна вывести слово YES или NO.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1/n1/n1/n1/n1 -> YES.

  - :code:`пример 2`		:  2/n2/n2/n1/n1 -> NO.

номер появления слова
~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_020.cpp` :: :code:`coderun` : :code:`easy` : :code:`standard library' : :code:`dict' : :code:`counting`

  - Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.

  - :code:`формат ввода`	: Вводится текст.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  one two one tho three -> 0 0 1 0 0.

  - :code:`пример 2`		:  aba aba; aba @?" -> 0 0 1 0.