######
coding
######

0: about this project
=====================

me solving coderun, codeforces, codewars and leetcode problems to 'git gud'.

1.1: project layout
===================

- :code:`root`: The :code:`CMakeLists.txt` and :code:`.command` files are located directly in the root folder.

  - :code:`/bin`: contains the :code:`solution` executable file.

  - :code:`/build`: contains the :code:`cmake` generated build files.

  - :code:`/source`: contains the :code:`solution.cpp` source file.

2: cmake
========

.. code-block::

	cmake_minimum_required(VERSION 3.28)
	project("coding")

	set (CMAKE_CXX_STANDARD 11)

	add_executable(solution 
	  "source/solution.cpp"
	)

	install(TARGETS solution DESTINATION "${PROJECT_SOURCE_DIR}/bin/")

3: build
========

- :code:`solution.command` contains the following:

  - :code:`~/projectRoot rm -rf build/` and :code:`~/projectRoot mkdir build` basically clears the build directory.

  - :code:`cd build`: enters the directory.

  - :code:`cmake ..`: builds the :code:`CMakeLists.txt` located in the parent directory.

  - :code:`make install`: creates the :code:`solution` executable and puts it in the :code:`~/projectRoot/bin` directory.

  - :code:`cd ../bin`: enters the /bin directory.

  - :code:`./solution`: launches the executable.

4: problems
===========

coderun: intro.
---------------

юля, никита и задачи.
~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_001.cpp` :: :code:`coderun` : :code:`easy` :

  - Подготовка задач к сезону это долгий и кропотливый процесс. Юля знает, что уже готово A задач. Никита выяснил, что ещё B задач почти готовы и в ближайшее время будут добавлены в сезон. Помогите Юле и Никите узнать, сколько всего задач планируется в сезоне.

  - :code:`формат ввода`	: Первая строка содержит два числа *A* и *B* (0 <= *A, B* <= 2 * 10\ :sup:`18`), разделённые пробелом.

  - :code:`формат вывода`	: Выведите одно число - *A* + *B* - суммарное количество задач в сезоне.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 1 1 -> 2.

  - :code:`пример 2`		: 4 1 -> 5.

  - :code:`пример 3`		: 1 3 -> 4.

треугольник.
~~~~~~~~~~~~

- :code:`coderun_002.cpp` :: :code:`coderun` : :code:`easy` : :code:`geometry` :

  - Даны три натуральных числа. Возможно ли построить треугольник с такими сторонами? Если это возможно, выведите строку YES, иначе выведите строку NO. Треугольник — это три точки, не лежащие на одной прямой.

  - :code:`формат ввода`	: Вводятся три натуральных числа.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 3 4 5 -> YES.

  - :code:`пример 2`		: 3 5 4 -> YES.

  - :code:`пример 3`		: 4 5 3 -> YES.

больше чем соседи.
~~~~~~~~~~~~~~~~~~

- :code:`coderun_003.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search` :

  - Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей. Выведите количество таких элементов.

  - :code:`формат ввода`	: Вводится список чисел. Все числа списка находятся на одной строке.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 1 2 3 4 5 -> 0.

  - :code:`пример 2`		: 5 4 3 2 1 -> 0.

  - :code:`пример 3`		: 1 5 1 5 1 -> 0.

выставление тегов
~~~~~~~~~~~~~~~~~

- :code:`coderun_004.cpp` :: :code:`coderun` : :code:`easy` :

  - Большинство задач сезона CodeRun имеют теги, помогающие пользователям выбрать подходящий алгоритм для решения. Известно, что для первой и второй задач каждого трека количество тегов равно 1 (*t* [1]= *t* [2]=1), а для всех следующих количество тегов вычисляется по следующему правилу: *t* [*i*]= *t* [*i* − 1]+ *t* [*i* −2], где *t* [*i*] - количество тегов задачи с номером *i*. Было установлено, что на выставление одного тега требуется одна секунда. Посчитайте, сколько всего времени потребуется для выставления всех тегов.

  - :code:`формат ввода`	: На вход подаётся одно целое число *n* (1 <= *n* <= 35) - количество задач в треке.

  - :code:`формат вывода`	: Выведите одно целое число - сумму *t* [*i*] - время, необходимое для расстановки тегов всех задач.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		: 32 -> 5702866.

  - :code:`пример 2`		: 21 -> 28656.

  - :code:`пример 3`		: 33 -> 9227464.

29 задача аналитики
~~~~~~~~~~~~~~~~~~~

- :code:`coderun_005.cpp` :: :code:`coderun` : :code:`easy` :

  - В трек аналитики второго сезона вошло 28 задач, однако кроме них была подготовлена ещё одна задача. Так как в сезон она не вошла, то предлагаем решить вам её сейчас. Вам дано квадратное уравнение вида: *ax*\ :sup:`2` + *bx* + *c* = 0, где *a*, *b* и *c* - целые числа, такие, что *a* != 0. Напишите программу, которая решает это уравнение.

  - :code:`формат ввода`	: Единственная строка входных данных содержит три целых числа *a*, *b*, *c* (-10\ :sup:`3` <= *a*, *b*, *c* <= 10\ :sup:`3`, a != 0).

  - :code:`формат вывода`	: В первой строке выведите количество корней уравнения. Во второй строке выведите сами корни. Если уравнение имеет два корня, то выведите их через пробел в порядке **возрастания**. Если корень один, то выведите его. Если корней нет, то ничего выводить не нужно. Ваш ответ будет принят, если выведенные числа отличаются от правильных ответов на величину не более 10\ :sup:`-6`.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 -2  1 -> 1/n1.000000.

  - :code:`пример 2`		:  5  0  3 -> 0.

  - :code:`пример 3`		:  6 -5 -8 -> 2/n-0.810910 1.644243

OpenCalculator
~~~~~~~~~~~~~~

- :code:`coderun_006.cpp` :: :code:`coderun` : :code:`easy` : :code:`set` : :code:`standard library` :

  - В новой программе OpenCalculator появилась новая возможность – можно настроить, какие кнопки отображаются, а какие – нет. Если кнопка не отображается на экране, то ввести соответствующую цифру с клавиатуры или копированием из другой программы нельзя. Петя настроил калькулятор так, что он отображает только кнопки с цифрами x, y, z. Напишите программу, определяющую, сможет ли Петя ввести число N, а если нет, то какое минимальное количество кнопок надо дополнительно отобразить на экране для его ввода.

  - :code:`формат ввода`	: Сначала вводятся три различных числа из диапазона от 0 до 9: x, y и z (числа разделяются пробелами). Далее вводится целое неотрицательное число N, которое Петя хочет ввести в калькулятор. Число N не превышает 10000.

  - :code:`формат вывода`	: Выведите, какое минимальное количество кнопок должно быть добавлено для того, чтобы можно было ввести число N (если число может быть введено с помощью уже имеющихся кнопок, выведите 0).

  - :code:`примечание`	: Комментарии к примерам тестов.

    - Число может быть введено имеющимися кнопками.

    - Нужно добавить кнопку 0.

    - Нужно добавить кнопки 1 и 2.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 2 3/n1123 -> 0.

  - :code:`пример 2`		:  1 2 3/n1001 -> 1.

  - :code:`пример 3`		:  5 7 3/n123  -> 2.

количество слов в тексте
~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_007.cpp` :: :code:`coderun` : :code:`easy` : :code:`line handling` : :code:`set` : :code:`standard library` :

  - Во входном файле записан текст (вы можете читать данные из sys.stdin, подключив библиотеку sys). Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Определите, сколько **различных** слов содержится в этом тексте.

  - :code:`формат ввода`	: Вводится текст.

  - :code:`формат вывода`	: Выведите ответ на задачу.

  - :code:`ограничения`		: 1 с, 64 мб.

возрастает ли список?
~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_008.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search` :

  - Дан список. Определите, является ли он монотонно возрастающим (то есть верно ли, что каждый элемент этого списка строго больше предыдущего). Выведите YES, если массив монотонно возрастает и NO в противном случае.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 7 9 -> YES.

  - :code:`пример 2`		:  1 9 7 -> NO.

  - :code:`пример 3`		:  2 2 2 -> NO.

умножай и транспонируй
~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_009.cpp` :: :code:`coderun` : :code:`easy` :

  - Школьники из объединения КРОШ (Клуб Решателей Олимпиад Школьников) готовятся к участию в треке ML. Начать подготовку они решили с изучения линейной алгебры. Выяснилось, что существует две интересные операции над матрицами - умножение и траспонирование. Они составили много примеров и решают их на листике, однако им нужна помощь в проверке результатов. Напишите программу, которая по заданным матрицам *A* и *B* вычисляет: ( *A* × *B* )\ :sup:`T`, где *A* - матрица размером *n* × *m*, а *B* - матрица размером *m* × *k*.

  - :code:`формат ввода`	: В первой стоке вводятся 3 числа *n*, *m*, *k* (1 <= *n*, *m*, *k* <= 100). Далее следуют *n* строк по *m* чисел в каждой - элементы матрицы *A* (0 <= *A*\ :sub:`i,j`\  <= 10). Затем вводятся *m* строк по *k* чисел в каждой - элементы матрицы *B* (0 <= *B*\ :sub:`i,j`\   <= 10).

  - :code:`формат вывода`	: Выведите матрицу результата операции ( *A* × *B* )\ :sup:`T`.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  1 2 1/n3 4/n9/n8 -> 59.

  - :code:`пример 2`		:  2 1 3/n0/n2/n1 2 8 -> 0 2/n0 4/n0 16.

  - :code:`пример 3`		:  6 1 4/n6/n1/n3/n3/n1/n9/n10 2 0 3 -> 60 10 30 30 10 90/n12 2 6 6 2 18/n0 0 0 0 0 0/n18 3 9 9 3 27.

ещё одна задача на теорию чисел
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_010.cpp` :: :code:`coderun` : :code:`easy` :

  - Лене очень нравится теория чисел. В прошлый раз она просила участников сезона угадать функцию Эйлера. К сожалению, для некоторых пользователей эта задача оказалась слишком сложной, поэтому Лена придумала задачку попроще. Вам даны 2 натуральных числа *a* и *b*. Необходимо посчитать НОД(a, b) и НОК(a, b). Напомним, что: НОД(a, b) - наибольшее натуральное число, на которое числа *a* и *b* делятся без остатка. НОК(a, b) - ннаименьшее натуральное число, которое делится на числа *a* и *b* без остатка.

  - :code:`формат ввода`	: Единственная входная строка содержит два числа - *a*, *b* (1 <= *a*, *b* <= 10\ :sup:`9`).

  - :code:`формат вывода`	: Выведите 2 целых числа - НОД(a, b) и НОД(a, b).

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  20 8 -> 4 40.

  - :code:`пример 2`		:  2 3 -> 1 6.

  - :code:`пример 3`		:  5 15 -> 5 15.

словарь синонимов
~~~~~~~~~~~~~~~~~

- :code:`coderun_011.cpp` :: :code:`coderun` : :code:`easy` : :code:`standard library` : :code:`dict`

  - Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.

  - :code:`формат ввода`	: Программа получает на вход количество пар синонимов *N*. Далее следует *N* строк, каждая строка содержит ровно два слова-синонима. После этого следует одно слово.

  - :code:`формат вывода`	: Программа должна вывести синоним к данному слову.

  - :code:`примечание`		: Эту задачу можно решить и без словарей (сохранив все входные данные в списке), но решение со словарем будет более простым.

  - :code:`ограничения`		: 1 с, 256 мб.

  - :code:`пример 1`		:  3/nHello Hi/nBye Goodbye/nList Array/nGoodbye -> Bye.

  - :code:`пример 2`		:  1/nbeep Car/nCar -> beep.

  - :code:`пример 3`		:  2/nOlolo Ololo/nNumbers 1234567890/nNumbers -> 1234567890.

ближайшее число
~~~~~~~~~~~~~~~

- :code:`coderun_012.cpp` :: :code:`coderun` : :code:`easy` : :code:`linear search`

  - Напишите программу, которая находит в массиве элемент, самый близкий по величине к данному числу.

  - :code:`формат ввода`	: В первой строке задается одно натуральное число *N*, не превосходящее 1000 — размер массива. Во второй строке содержатся *N* чисел — элементы массива, целые числа, не превосходящие по модулю 1000. В третьей строке вводится одно целое число *x*, не превосходящее по модулю 1000.

  - :code:`формат вывода`	: Вывести значение элемента массива, ближайшее к *x*. Если таких чисел несколько, выведите любое из них.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  5/n1 2 3 4 5/n6 -> 5.

  - :code:`пример 2`		:  5/n5 4 3 2 1/n3 -> 3.

симметричная последовательность
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- :code:`coderun_013.cpp` :: :code:`coderun` : :code:`easy` : :code:`implementation`

  - Последовательность чисел назовём симметричной, если она одинаково читается как слева направо, так и справа налево. Например, следующие последовательности являются симметричными: 1 2 3 4 5 4 3 2 1 и 1 2 1 2 2 1 2 1. Вашей программе будет дана последовательность чисел. Требуется определить, какое минимальное количество и каких чисел надо приписать в конец этой последовательности, чтобы она стала симметричной.

  - :code:`формат ввода`	: ВСначала вводится число *N* — количество элементов исходной последовательности (1 <= *N* <= 100). Далее идут *N* чисел — элементы этой последовательности, натуральные числа от 1 до 9.

  - :code:`формат вывода`	: Выведите сначала число *M* — минимальное количество элементов, которое надо дописать к последовательности, а потом *M* чисел (каждое — от 1 до 9) — числа, которые надо дописать к последовательности.

  - :code:`ограничения`		: 1 с, 64 мб.

  - :code:`пример 1`		:  9/n1 2 3 4 5 4 3 2 1 -> 0.

  - :code:`пример 2`		:  5/n1 2 1 2 2 -> 3/n1 2 1.

  - :code:`пример 3`		:  5/n1 2 3 4 5 -> 4/n4 3 2 1.